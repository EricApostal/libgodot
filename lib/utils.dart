import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as pkg_ffi;
import 'package:libgodot/generated_bindings.dart';

GDExtensionInterfaceGetProcAddressFunction? _getProcAddressFn;

ffi.Pointer<ffi.Void> godotResolve(String name) {
  final getter = _getProcAddressFn;
  if (getter == null) return ffi.nullptr;
  final cstr = name.toNativeUtf8();
  try {
    final raw = getter(cstr.cast());
    return raw.cast<ffi.Void>();
  } finally {
    pkg_ffi.malloc.free(cstr);
  }
}

void storeGetProcAddress(GDExtensionInterfaceGetProcAddress ptr) {
  // Convert the raw function pointer into a Dart callable and cache.
  _getProcAddressFn = ptr
      .asFunction<GDExtensionInterfaceGetProcAddressFunction>();
}

ffi.Pointer<ffi.NativeFunction<T>>?
resolveInterfaceFunction<T extends Function>(String name) {
  final raw = godotResolve(name);
  if (raw == ffi.nullptr) return null;
  return raw.cast<ffi.NativeFunction<T>>();
}

/// Resolve and return a global singleton Object pointer (e.g. "DisplayServer").
///
/// Returns `ffi.nullptr` if either required interface functions are missing or
/// the singleton is not found. Caller owns the temporary StringName memory
/// which is currently leaked intentionally (the destroy function was not
/// generated by ffigen). This is acceptable for infrequent lookups during
/// startup; for repeated calls, add the corresponding string_name destroy
/// binding and free.
GDExtensionObjectPtr godotGetGlobalSingleton(String name) {
  // Required interface procs: string_name_new_with_utf8_chars, global_get_singleton
  final newStrFnPtr =
      resolveInterfaceFunction<
        GDExtensionInterfaceStringNameNewWithUtf8CharsFunction
      >('string_name_new_with_utf8_chars');
  final getSingletonFnPtr =
      resolveInterfaceFunction<GDExtensionInterfaceGlobalGetSingletonFunction>(
        'global_get_singleton',
      );

  if (newStrFnPtr == null || getSingletonFnPtr == null) {
    return ffi.nullptr;
  }

  final newStrFn = newStrFnPtr
      .asFunction<DartGDExtensionInterfaceStringNameNewWithUtf8CharsFunction>();
  final getSingletonFn = getSingletonFnPtr
      .asFunction<GDExtensionInterfaceGlobalGetSingletonFunction>();

  // Allocate raw storage for an uninitialized StringName. Size is opaque; we
  // conservatively allocate 32 bytes which is enough for current builds.
  // TODO: Expose string_name_get_size or rely on generated size once available.
  final storage = pkg_ffi.calloc<ffi.Uint8>(32).cast<ffi.Void>();

  final cname = name.toNativeUtf8();
  try {
    newStrFn(storage, cname.cast());
    final singleton = getSingletonFn(storage.cast());
    return singleton;
  } catch (_) {
    return ffi.nullptr;
  } finally {
    // Leak storage for now (see doc comment). We still free the temporary C string.
    pkg_ffi.malloc.free(cname);
  }
}
